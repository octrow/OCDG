import json
import os
import re
import sqlite3
import time
import traceback
from sys import stdout
from typing import Any

import git

from openai import OpenAI

from dotenv import load_dotenv

load_dotenv()

NVIDIA_API_KEY = os.getenv("NVIDIA_API_KEY")
if NVIDIA_API_KEY is None:
    print("Please set the NVIDIA_API_KEY environment variable.")
    exit(1)


# Create directory for commit diffs
commit_diff_dir = "commit_diff"
os.makedirs(commit_diff_dir, exist_ok=True)
print(f"Created directory: {commit_diff_dir}")

# Initialize the OpenAI clients
client = OpenAI(
  base_url = "https://integrate.api.nvidia.com/v1",
  api_key = NVIDIA_API_KEY
)
print("Initialized the OpenAI clients")

# Create a SQLite3 database and table for storing commit information
conn = sqlite3.connect('commits.db')
c = conn.cursor()
c.execute('''CREATE TABLE IF NOT EXISTS commits
             (hash text PRIMARY KEY, author text, date text, message text, status boolean)''')
print("Created commits table")



def find_closing_brace_index(text):
    count = 0
    for i, char in enumerate(text):
        if char == '{':
            count += 1
        elif char == '}':
            count -= 1
            if count == 0:
                return i
    raise ValueError("Unbalanced curly braces")

def parse_output_string(output_string):
    data = {}
    patterns = {
        'short_analysis': r'\*\*Short analysis\*\*: (.+?)\n',
        'commit_title': r'\*\*New Commit Title\*\*: (.+?)\n',
        'detailed_commit_message': r'\*\*New Detailed Commit Message\*\*:\n(.+?)\n\n\*\*Code Changes\*\*:',
        'code_changes': r'\*\*Code Changes\*\*:\n```\n(\{.+\})\n```'
    }
    # Extracting each part using regular expressions
    for key, pattern in patterns.items():
        match = re.search(pattern, output_string, re.DOTALL)
        if match:
            if key == 'code_changes':
                # Convert string representation of dictionary to actual dictionary
                data[key] = json.loads(match.group(1))
            else:
                data[key] = match.group(1).strip()

    print(json.dump(data, fp=stdout, indent=2))
    return data

def generate_commit_multi(diff, commit_message):
    # Split the diff into chunks of size 6000
    diff_chunks = [diff[i:i + 6000] for i in range(0, len(diff), 6000)]

    # Initialize empty lists to store different parts of the commit message
    short_analysis = []
    new_commit_title = []
    new_detailed_commit_message = []
    code_changes = []

    for diff_chunk in diff_chunks:
        system_prompt = (f""""
        I would like you to perform a detailed analysis of a GitHub repository's commit history. 
        Here's what I need you to do:

        1. Analyze the code differences and provide a brief, insightful comment on what was changed 
        and why it might have been done, considering the context of the commit message.
        2. Compile all this information into a single new commit message following Commit Message Guidelines.

        ## Commit Message Guidelines
        Short (72 chars or less) summary

        More detailed explanatory text. Wrap it to 72 characters. The blank
        line separating the summary from the body is critical (unless you omit
        the body entirely).

        Write your commit message in the imperative: 'Fix bug' and not 'Fixed
        bug' or 'Fixes bug.' This convention matches up with commit messages
        generated by commands like git merge and git revert.

        Further paragraphs come after blank lines.

        - Bullet points are okay, too.
        - Typically a hyphen or asterisk is used for the bullet, followed by a
          single space. Use a hanging indent.

        ## Original Commit Message
        {commit_message}

        ## Code Differences
        {diff_chunk}

        ## Output only in JSON Format
        {{
        "Short analysis": "str",
        "New Commit Title": "str",
        "New Detailed Commit Message": "str",
        "Code Changes: {{"filename": "str", filename2: "str"}}",
        }}
            """)
        chat_completion = client.chat.completions.create(
            model="meta/llama3-70b-instruct",
            messages=[{"role": "user", "content": system_prompt}],
            max_tokens=2000,
            temperature=0.5,
            top_p=1,
        )
        generated_message = parse_output_string(chat_completion.choices[0].message.content)
    new_commit_message = {
        "Short analysis": generated_message.get("short_analysis", ""),
        "New Commit Title": generated_message.get("commit_title", ""),
        "New Detailed Commit Message": generated_message.get("detailed_commit_message", ""),
        "Code Changes": generated_message.get("code_changes", ""),
    }
    return new_commit_message


def combine_messages(multi_commit: dict[dict[str: Any],]) -> dict[str, Any]:
    prompt = f"""Combine the following messages into a single commit message:
    {json.dumps(multi_commit)}"""
    chat_completion = client.chat.completions.create(
        model="meta/llama3-70b-instruct",
        messages=[
            {"role": "user", "content": json.dumps(multi_commit)}
        ],
        max_tokens=2000,
        temperature=0.5,
        top_p=1,
    )
    return parse_output_string(chat_completion.choices[0].message.content)

# Function to generate new commit message using Replicate API
def generate_new_commit_message(diff, commit_message, system_prompt=None):
    if len(diff) >= 6000:
        print("Diff is too long. Strat splitting it into chunks.")
        multi_commit = generate_commit_multi(diff, commit_message)
        new_commit_message = combine_messages(multi_commit)
        print(f"New commit combined message: {new_commit_message}")
        return new_commit_message

    chat_completion = client.chat.completions.create(
        model="meta/llama3-70b-instruct",
        messages=[{"role": "user", "content": system_prompt}],
        max_tokens=2000,
        temperature=0.5,
        top_p=1,
    )
    generated_message = parse_output_string(chat_completion.choices[0].message.content)
    new_commit_message = {
        "Short analysis": generated_message.get("short_analysis", ""),
        "New Commit Title": generated_message.get("commit_title", ""),
        "New Detailed Commit Message": generated_message.get("detailed_commit_message", ""),
        "Code Changes": generated_message.get("code_changes", {}),
    }
    print(f"New commit message: {new_commit_message}")
    return new_commit_message


def update_commit_status(hash, status):
    c.execute("UPDATE commits SET status = ? WHERE hash = ?", (status, hash))
    conn.commit()


def write_commit_info_to_file(filename, hash, author, date, message, diff_content):
    with open(filename, 'w') as file:
        file.write(f"Commit: {hash}\n")
        file.write(f"Author: {author}\n")
        file.write(f"Date: {date}\n")
        file.write(f"Message: {message}\n")
        file.write('Diff:\n')
        file.write(diff_content)


def update_commit_descriptions(status):
    repo = git.Repo(".")  # Open the current Git repository

    # Get commits with status=True from the database
    c.execute("SELECT hash, date FROM commits WHERE status=?", (status,))
    commits_to_update = c.fetchall()

    for commit_hash, commit_date in commits_to_update:
        filename = f"{commit_diff_dir}/{commit_date}_{commit_hash}_new_message.txt"

        # Read the new commit message from the file
        with open(filename, 'r') as file:
            new_commit_message = file.read()

        # Get the original commit object
        commit = repo.commit(commit_hash)

        # Create a new commit with the updated message
        new_commit = repo.index.commit(new_commit_message,
                                       parent_commits=(commit.parents[0],),
                                       author=commit.author,
                                       committer=commit.committer)

        # Perform an interactive rebase to replace the old commit with the new one
        print(f"Rebasing commit {commit.hexsha} with {new_commit.hexsha}")
        print(f'new commit: {new_commit}')
        # repo.git.rebase('-i', commit.parents[0].hexsha, new_commit.hexsha)

# Extract commit information and loop over each commit
commits = os.popen("git log --pretty=format:'%h,%an,%ad,%s' --date=format:%Y-%m-%d").read().strip().split('\n')
print(f"Extracted {len(commits)} commits")
for commit_info in commits:
    print(f"Processing commit: {commit_info}")
    hash, author, date, message = commit_info.split(',', maxsplit=3)
    print(f"Commit: {hash}, Author: {author}, Date: {date}, Message: {message}")
    # Format the filename using commit date and hash
    filename = f"{commit_diff_dir}/{date}_{hash}.diff"
    print(f"Filename: {filename}")
    try:
        diff_content = os.popen(f"git diff {hash}^!").read()
    except Exception as e:
        print(f"Error executing git diff: {e}")
        continue # Skip this commit
    # Write commit info and diff to the separate file
    write_commit_info_to_file(filename, hash, author, date, message, diff_content)

    # Generate new commit message
    status = True
    try:
        new_commit_message = generate_new_commit_message(diff_content, message)
        print(f"New commit message: {new_commit_message}...")
        # Save the new commit message
        new_message_filename = f"{commit_diff_dir}/{date}_{hash}_new_message.txt"
        with open(new_message_filename, 'w') as file:
            file.write(str(new_commit_message))
    except Exception as e:
        print(f"Exception: {traceback.format_exc()} {str(e)}")
        status = False
    finally:
        update_commit_descriptions(status)  # Update descriptions regardless of success or error
        if not status:
            break
        update_commit_status(hash, True)



