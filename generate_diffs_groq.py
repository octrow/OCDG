import json
import os
import re
import sqlite3
import time
import git

# import replicate
from groq import Groq
from groq import RateLimitError, APIStatusError


from dotenv import load_dotenv
#
load_dotenv()

GROQ_API_KEY = os.getenv("GROQ_API_KEY")
if GROQ_API_KEY is None:
    print("Please set the GROQ_API_KEY environment variable.")
    exit(1)


# Create directory for commit diffs
commit_diff_dir = "commit_diff"
os.makedirs(commit_diff_dir, exist_ok=True)
print(f"Created directory: {commit_diff_dir}")

# Initialize the Groq client
client = Groq(
    api_key=GROQ_API_KEY,
)
print("Initialized the Groq client")

# Create a SQLite3 database and table for storing commit information
conn = sqlite3.connect('commits.db')
c = conn.cursor()
c.execute('''CREATE TABLE IF NOT EXISTS commits
             (hash text PRIMARY KEY, author text, date text, message text, status boolean)''')
print("Created commits table")

# Function to generate new commit message using Replicate API
def generate_new_commit_message(diff, commit_message, system_prompt=None):
    system_prompt = (f""""
I would like you to perform a detailed analysis of a GitHub repository's commit history. 
Here's what I need you to do:

1. Analyze the code differences and provide a brief, insightful comment on what was changed 
and why it might have been done, considering the context of the commit message.
2. Compile all this information into a single new commit message following Commit Message Guidelines.

## Commit Message Guidelines
Short (72 chars or less) summary

More detailed explanatory text. Wrap it to 72 characters. The blank
line separating the summary from the body is critical (unless you omit
the body entirely).

Write your commit message in the imperative: 'Fix bug' and not 'Fixed
bug' or 'Fixes bug.' This convention matches up with commit messages
generated by commands like git merge and git revert.

Further paragraphs come after blank lines.

- Bullet points are okay, too.
- Typically a hyphen or asterisk is used for the bullet, followed by a
  single space. Use a hanging indent.

## Original Commit Message
{commit_message}

## Code Differences
{diff}

## Output only in JSON Format
{{
"Short analysis": "str",
"New Commit Title": "str",
"New Detailed Commit Message": "str",
"Code Changes: {{"filename": "str", filename2: "str"}}",
}}
""")
    chat_completion = client.chat.completions.create(
        messages=[
            {"role": "system", "content": system_prompt},
        ],
        model="llama3-70b-8192",  # Choose appropriate Groq model
        max_tokens=512,
        temperature=0.6,
    )
    new_commit_message = chat_completion.choices[0].message.content
    print(f"New commit message: {new_commit_message}")
    return new_commit_message


def update_commit_status(hash, status):
    c.execute("UPDATE commits SET status = ? WHERE hash = ?", (status, hash))
    conn.commit()


def write_commit_info_to_file(filename, hash, author, date, message, diff_content):
    with open(filename, 'w') as file:
        file.write(f"Commit: {hash}\n")
        file.write(f"Author: {author}\n")
        file.write(f"Date: {date}\n")
        file.write(f"Message: {message}\n")
        file.write('Diff:\n')
        file.write(diff_content)


def update_commit_descriptions(status):
    repo = git.Repo(".")  # Open the current Git repository

    # Get commits with status=True from the database
    c.execute("SELECT hash, date FROM commits WHERE status=?", (status,))
    commits_to_update = c.fetchall()

    for commit_hash, commit_date in commits_to_update:
        filename = f"{commit_diff_dir}/{commit_date}_{commit_hash}_new_message.txt"

        # Read the new commit message from the file
        with open(filename, 'r') as file:
            new_commit_message = file.read()

        # Get the original commit object
        commit = repo.commit(commit_hash)

        # Create a new commit with the updated message
        new_commit = repo.index.commit(new_commit_message,
                                       parent_commits=(commit.parents[0],),
                                       author=commit.author,
                                       committer=commit.committer)

        # Perform an interactive rebase to replace the old commit with the new one
        print(f"Rebasing commit {commit.hexsha} with {new_commit.hexsha}")
        print(f'new commit: {new_commit}')
        # repo.git.rebase('-i', commit.parents[0].hexsha, new_commit.hexsha)

# Extract commit information and loop over each commit
commits = os.popen("git log --pretty=format:'%h,%an,%ad,%s' --date=format:%Y-%m-%d").read().strip().split('\n')
print(f"Extracted {len(commits)} commits")
for commit_info in commits:
    print(f"Processing commit: {commit_info}")
    hash, author, date, message = commit_info.split(',', maxsplit=3)
    print(f"Commit: {hash}, Author: {author}, Date: {date}, Message: {message}")
    # Format the filename using commit date and hash
    filename = f"{commit_diff_dir}/{date}_{hash}.diff"
    print(f"Filename: {filename}")
    try:
        diff_content = os.popen(f"git diff {hash}^!").read()
    except Exception as e:
        print(f"Error executing git diff: {e}")
        continue # Skip this commit
    # Write commit info and diff to the separate file
    write_commit_info_to_file(filename, hash, author, date, message, diff_content)

    # Generate new commit message
    try:
        new_commit_message = generate_new_commit_message(diff_content, message)
        print(f"New commit message: {new_commit_message[0:100]}...")
    except RateLimitError as e:
        print(f"Rate limit error encountered: {e}")
        # Wait for the specified time before retrying
        match = re.search(r'Please try again in (\d+\.?\d*)', str(e))
        if match:
            retry_after = float(match.group(1))
        print(f"Retrying after {retry_after} seconds...")
        time.sleep(retry_after)
    except APIStatusError as e:
        print(f"API status error encountered: {e}")
        # Check type of error
        # groq.APIStatusError: Error code: 413 - {'error': {'message': 'Request Entity Too Large', 'type': 'invalid_request_error', 'code': 'request_too_large'}}
        # func for split file in two parts
        print(f"...")
    finally:
        update_commit_descriptions()  # Update descriptions regardless of success or error


    # Save the new commit message
    new_message_filename = f"{commit_diff_dir}/{date}_{hash}_new_message.txt"
    with open(new_message_filename, 'w') as file:
        file.write(new_commit_message)
    # Update the status of the commit in the SQLite3 table
    update_commit_status(hash, True)
